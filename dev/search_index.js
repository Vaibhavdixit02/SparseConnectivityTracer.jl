var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#Interface","page":"API Reference","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"connectivity\nTracerSparsityDetector","category":"page"},{"location":"api/#SparseConnectivityTracer.connectivity","page":"API Reference","title":"SparseConnectivityTracer.connectivity","text":"connectivity(f, x)\n\nEnumerates inputs x and primal outputs y=f(x) and returns sparse connectivity matrix C of size (m, n) where C[i, j] is true if the compute graph connects the i-th entry in y to the j-th entry in x.\n\nExample\n\njulia> x = rand(3);\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> connectivity(f, x)\n3×3 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 4 stored entries:\n 1  ⋅  ⋅\n 1  1  ⋅\n ⋅  ⋅  1\n\n\n\n\n\nconnectivity(f!, y, x)\n\nEnumerates inputs x and primal outputs y after f!(y, x) and returns sparse connectivity matrix C of size (m, n) where C[i, j] is true if the compute graph connects the i-th entry in y to the j-th entry in x.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseConnectivityTracer.TracerSparsityDetector","page":"API Reference","title":"SparseConnectivityTracer.TracerSparsityDetector","text":"TracerSparsityDetector <: ADTypes.AbstractSparsityDetector\n\nSingleton struct for integration with the sparsity detection framework of ADTypes.jl.\n\nExample\n\njulia> using ADTypes, SparseConnectivityTracer\n\njulia> ADTypes.jacobian_sparsity(diff, rand(4), TracerSparsityDetector())\n3×4 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 6 stored entries:\n 1  1  ⋅  ⋅\n ⋅  1  1  ⋅\n ⋅  ⋅  1  1\n\n\n\n\n\n","category":"type"},{"location":"api/#Internals","page":"API Reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SparseConnectivityTracer works by pushing a Number type called Tracer through generic functions:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Tracer\ntracer\ntrace_input","category":"page"},{"location":"api/#SparseConnectivityTracer.Tracer","page":"API Reference","title":"SparseConnectivityTracer.Tracer","text":"Tracer(indexset) <: Number\n\nNumber type keeping track of input indices of previous computations.\n\nSee also the convenience constructor tracer. For a higher-level interface, refer to connectivity.\n\nExamples\n\nBy enumerating inputs with tracers, we can keep track of input connectivities:\n\njulia> xt = [tracer(1), tracer(2), tracer(3)]\n3-element Vector{Tracer}:\n Tracer(1,)\n Tracer(2,)\n Tracer(3,)\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> yt = f(xt)\n3-element Vector{Tracer}:\n   Tracer(1,)\n Tracer(1, 2)\n   Tracer(3,)\n\nThis works by overloading operators to either keep input connectivities constant,  compute unions or set connectivities to zero:\n\njulia> x = tracer(1, 2, 3)\nTracer(1, 2, 3)\n\njulia> sin(x)  # Most operators don't modify input connectivities.\nTracer(1, 2, 3)\n\njulia> 2 * x^3\nTracer(1, 2, 3)\n\njulia> zero(x) # Tracer is strictly operator overloading... \nTracer()\n\njulia> 0 * x   # ...and doesn't look at input values.\nTracer(1, 2, 3)\n\njulia> y = tracer(3, 5)\nTracer(3, 5)\n\njulia> x + y   # Operations on two Tracers construct union sets\nTracer(1, 2, 3, 5)\n\njulia> x ^ y\nTracer(1, 2, 3, 5)\n\nTracer also supports random number generation and pre-allocations:\n\njulia> M = rand(Tracer, 3, 2)\n3×2 Matrix{Tracer}:\n Tracer()  Tracer()\n Tracer()  Tracer()\n Tracer()  Tracer()\n\njulia> similar(M)\n3×2 Matrix{Tracer}:\n Tracer()  Tracer()\n Tracer()  Tracer()\n Tracer()  Tracer()\n\njulia> M * [x, y]\n3-element Vector{Tracer}:\n Tracer(1, 2, 3, 5)\n Tracer(1, 2, 3, 5)\n Tracer(1, 2, 3, 5)\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseConnectivityTracer.tracer","page":"API Reference","title":"SparseConnectivityTracer.tracer","text":"tracer(index)\ntracer(indices)\n\nConvenience constructor for Tracer from input indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseConnectivityTracer.trace_input","page":"API Reference","title":"SparseConnectivityTracer.trace_input","text":"trace_input(x)\n\nEnumerates input indices and constructs Tracers.\n\nExample\n\njulia> x = rand(3);\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> xt = trace_input(x)\n3-element Vector{Tracer}:\n Tracer(1,)\n Tracer(2,)\n Tracer(3,)\n\njulia> yt = f(xt)\n3-element Vector{Tracer}:\n   Tracer(1,)\n Tracer(1, 2)\n   Tracer(3,)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The following utilities can be used to extract input indices from Tracers:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"inputs","category":"page"},{"location":"api/#SparseConnectivityTracer.inputs","page":"API Reference","title":"SparseConnectivityTracer.inputs","text":"inputs(tracer)\n\nReturn raw UInt64 input indices of a Tracer.\n\nExample\n\njulia> t = tracer(1, 2, 4)\nTracer(1, 2, 4)\n\njulia> inputs(t)\n3-element Vector{Int64}:\n 1\n 2\n 4\n\n\n\n\n\n","category":"function"},{"location":"#SparseConnectivityTracer.jl","page":"Home","title":"SparseConnectivityTracer.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Aqua)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast sparsity detection via operator-overloading.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Will soon include Jacobian sparsity detection (#19) and Hessian sparsity detection (#20).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this package, open the Julia REPL and run ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add SparseConnectivityTracer","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using SparseConnectivityTracer\n\njulia> x = rand(3);\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> connectivity(f, x)\n3×3 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 4 stored entries:\n 1  ⋅  ⋅\n 1  1  ⋅\n ⋅  ⋅  1","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a larger example, let's compute the sparsity pattern from a convolutional layer from Flux.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SparseConnectivityTracer, Flux\n\njulia> x = rand(28, 28, 3, 1);\n\njulia> layer = Conv((3, 3), 3 => 8);\n\njulia> connectivity(layer, x)\n5408×2352 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 146016 stored entries:\n⎡⠙⢶⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠘⢷⣄⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠙⢷⣄⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠉⠳⣦⡀⎥\n⎢⠙⢷⣄⠀⠀⠀⠉⠻⣦⡀⠀⠀⠈⠙⢷⣄⠀⠀⠀⠈⠁⎥\n⎢⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠉⠳⣦⡀⠀⠀⎥\n⎢⠀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠈⠻⣦⡀⎥\n⎢⠙⢷⣄⠀⠀⠀⠉⠻⣦⡀⠀⠀⠈⠙⠷⣤⡀⠀⠀⠈⠁⎥\n⎢⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠈⠻⣦⡀⠀⠀⎥\n⎢⠀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⢦⣄⠀⠀⠀⠈⠻⣦⡀⎥\n⎢⠙⢷⣄⠀⠀⠀⠉⠻⣦⡀⠀⠀⠀⠉⠻⣦⡀⠀⠀⠈⠁⎥\n⎢⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⢦⣀⠀⠀⠀⠈⠻⣦⡀⠀⠀⎥\n⎢⠀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⎥\n⎢⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠙⢷⣄⠀⠀⠀⠈⠙⢶⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⎥\n⎢⣀⠀⠀⠀⠙⢷⣄⡀⠀⠀⠀⠙⢷⣄⡀⠀⠀⠈⠻⣦⡀⎥\n⎢⠙⢷⣄⠀⠀⠀⠈⠛⢶⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠙⢷⣄⠀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⎥\n⎢⣀⠀⠀⠀⠙⠳⣦⣀⠀⠀⠀⠙⢷⣄⡀⠀⠀⠈⠻⣦⡀⎥\n⎢⠙⢷⣄⠀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠙⠷⣄⡀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⎥\n⎢⣀⠀⠀⠀⠈⠻⣦⣀⠀⠀⠀⠙⢷⣄⡀⠀⠀⠈⠻⣦⡀⎥\n⎢⠙⠷⣄⡀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠈⠻⣦⡀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⣦⡀⠀⠀⎥\n⎣⠀⠀⠀⠀⠈⠻⣦⠀⠀⠀⠀⠙⢷⣄⠀⠀⠀⠈⠻⢦⡀⎦","category":"page"},{"location":"","page":"Home","title":"Home","text":"SparseConnectivityTracer enumerates inputs x and primal outputs y=f(x) and returns a sparse connectivity matrix C of size m times n, where C[i, j] is true if the compute graph connects the j-th entry in x to the i-th entry in y.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailled examples, take a look at the API reference.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SparseDiffTools.jl: automatic sparsity detection via Symbolics.jl and Cassette.jl\nSparsityTracing.jl: automatic Jacobian sparsity detection using an algorithm based on SparsLinC by Bischof et al. (1996)","category":"page"}]
}
