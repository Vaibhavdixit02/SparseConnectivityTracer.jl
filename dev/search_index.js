var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SparseConnectivityTracer","category":"page"},{"location":"#SparseConnectivityTracer","page":"Home","title":"SparseConnectivityTracer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SparseConnectivityTracer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#API-reference","page":"Home","title":"API reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SparseConnectivityTracer works by pushing a Number type called Tracer through generic functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tracer\ntracer","category":"page"},{"location":"#SparseConnectivityTracer.Tracer","page":"Home","title":"SparseConnectivityTracer.Tracer","text":"Tracer(indexset) <: Number\n\nNumber type keeping track of input indices of previous computations.\n\nSee also the convenience constructor tracer.\n\nExamples\n\njulia> x = tracer(1, 2, 3)\nTracer(1, 2, 3)\n\njulia> sin(x)\nTracer(1, 2, 3)\n\njulia> 2 * x^3\nTracer(1, 2, 3)\n\njulia> 0 * x   # Note: Tracer is strictly operator overloading...\nTracer(1, 2, 3)\n\njulia> zero(x) # ...this can be overloaded\nTracer()\n\njulia> y = tracer(3, 5)\nTracer(3, 5)\n\njulia> x + y\nTracer(1, 2, 3, 5)\n\njulia> x ^ y\nTracer(1, 2, 3, 5)\n\njulia> M = rand(Tracer, 3, 2)\n3×2 Matrix{Tracer}:\n Tracer()  Tracer()\n Tracer()  Tracer()\n Tracer()  Tracer()\n\njulia> similar(M)\n3×2 Matrix{Tracer}:\n Tracer()  Tracer()\n Tracer()  Tracer()\n Tracer()  Tracer()\n\njulia> M * [x, y]\n3-element Vector{Tracer}:\n Tracer(1, 2, 3, 5)\n Tracer(1, 2, 3, 5)\n Tracer(1, 2, 3, 5)\n\n\n\n\n\n","category":"type"},{"location":"#SparseConnectivityTracer.tracer","page":"Home","title":"SparseConnectivityTracer.tracer","text":"tracer(index)\ntracer(indices)\n\nConvenience constructor for Tracer from input indices.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"The resulting connectivity matrix can be extracted using connectivity: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"connectivity","category":"page"},{"location":"#SparseConnectivityTracer.connectivity","page":"Home","title":"SparseConnectivityTracer.connectivity","text":"connectivity(f, x)\n\nEnumerates inputs x and primal outputs y=f(x) and returns sparse connectivity matrix C of size (m, n) where C[i, j] is true if the compute graph connects the i-th entry in y to the j-th entry in x.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"or manually from individual Tracer outputs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"inputs\nsortedinputs","category":"page"},{"location":"#SparseConnectivityTracer.inputs","page":"Home","title":"SparseConnectivityTracer.inputs","text":"inputs(tracer)\n\nReturn raw UInt64 input indices of a Tracer.\n\n\n\n\n\n","category":"function"},{"location":"#SparseConnectivityTracer.sortedinputs","page":"Home","title":"SparseConnectivityTracer.sortedinputs","text":"sortedinputs(tracer)\nsortedinputs([T=Int], tracer)\n\nReturn sorted input indices of a Tracer.\n\n\n\n\n\n","category":"function"}]
}
