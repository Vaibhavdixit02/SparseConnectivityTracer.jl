var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#Interface","page":"API Reference","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"pattern\nTracerSparsityDetector","category":"page"},{"location":"api/#SparseConnectivityTracer.pattern","page":"API Reference","title":"SparseConnectivityTracer.pattern","text":"pattern(f, ConnectivityTracer{S}, x) where {S<:AbstractSet{<:Integer}}\n\nEnumerates inputs x and primal outputs y = f(x) and returns sparse matrix C of size (m, n) where C[i, j] is true if the compute graph connects the i-th entry in y to the j-th entry in x.\n\npattern(f, JacobianTracer{S}, x) where {S<:AbstractSet{<:Integer}}\n\nComputes the sparsity pattern of the Jacobian of y = f(x).\n\npattern(f, HessianTracer{S}, x) where {S<:AbstractSet{<:Integer}}\n\nComputes the sparsity pattern of the Hessian of a scalar function y = f(x).\n\nExamples\n\nFirst order\n\njulia> x = rand(3);\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> pattern(f, ConnectivityTracer{BitSet}, x)\n3×3 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 4 stored entries:\n 1  ⋅  ⋅\n 1  1  ⋅\n ⋅  ⋅  1\n\nSecond order\n\njulia> x = rand(5);\n\njulia> f(x) = x[1] + x[2]*x[3] + 1/x[4] + 1*x[5];\n\njulia> pattern(f, HessianTracer{BitSet}, x)\n5×5 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 3 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅\n\njulia> g(x) = f(x) + x[2]^x[5];\n\njulia> pattern(g, HessianTracer{BitSet}, x)\n5×5 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 7 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  1  ⋅  1\n ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅\n ⋅  1  ⋅  ⋅  1\n\n\n\n\n\npattern(f!, y, JacobianTracer{S}, x) where {S<:AbstractSet{<:Integer}}\n\nComputes the sparsity pattern of the Jacobian of f!(y, x).\n\npattern(f!, y, ConnectivityTracer{S}, x) where {S<:AbstractSet{<:Integer}}\n\nEnumerates inputs x and primal outputs y after f!(y, x) and returns sparse matrix C of size (m, n) where C[i, j] is true if the compute graph connects the i-th entry in y to the j-th entry in x.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseConnectivityTracer.TracerSparsityDetector","page":"API Reference","title":"SparseConnectivityTracer.TracerSparsityDetector","text":"TracerSparsityDetector <: ADTypes.AbstractSparsityDetector\n\nSingleton struct for integration with the sparsity detection framework of ADTypes.jl.\n\nExample\n\njulia> using ADTypes, SparseConnectivityTracer\n\njulia> ADTypes.jacobian_sparsity(diff, rand(4), TracerSparsityDetector())\n3×4 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 6 stored entries:\n 1  1  ⋅  ⋅\n ⋅  1  1  ⋅\n ⋅  ⋅  1  1\n\njulia> using ADTypes, SparseConnectivityTracer\n\njulia> f(x) = x[1] + x[2]*x[3] + 1/x[4];\n\njulia> ADTypes.hessian_sparsity(f, rand(4), TracerSparsityDetector())\n4×4 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 3 stored entries:\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅\n ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1\n\n\n\n\n\n","category":"type"},{"location":"api/#Internals","page":"API Reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SparseConnectivityTracer works by pushing Number types called tracers through generic functions. Currently, two tracer types are provided:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"ConnectivityTracer\nJacobianTracer\nHessianTracer","category":"page"},{"location":"api/#SparseConnectivityTracer.ConnectivityTracer","page":"API Reference","title":"SparseConnectivityTracer.ConnectivityTracer","text":"ConnectivityTracer{S}(indexset) <: Number\n\nNumber type keeping track of input indices of previous computations. The provided set type S has to be an AbstractSet{<:Integer}, e.g. BitSet or Set{UInt64}.\n\nSee also the convenience constructor tracer. For a higher-level interface, refer to pattern.\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseConnectivityTracer.JacobianTracer","page":"API Reference","title":"SparseConnectivityTracer.JacobianTracer","text":"JacobianTracer{S}(indexset) <: Number\n\nNumber type keeping track of input indices of previous computations with non-zero derivatives. The provided set type S has to be an AbstractSet{<:Integer}, e.g. BitSet or Set{UInt64}.\n\nSee also the convenience constructor tracer. For a higher-level interface, refer to pattern.\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseConnectivityTracer.HessianTracer","page":"API Reference","title":"SparseConnectivityTracer.HessianTracer","text":"HessianTracer{S}(indexset) <: Number\n\nNumber type keeping track of input indices of previous computations with non-zero first and second derivatives. The provided set type S has to be an AbstractSet{<:Integer}, e.g. BitSet or Set{UInt64}.\n\nSee also the convenience constructor tracer. For a higher-level interface, refer to pattern.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Utilities to create tracers:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"tracer\ntrace_input","category":"page"},{"location":"api/#SparseConnectivityTracer.tracer","page":"API Reference","title":"SparseConnectivityTracer.tracer","text":"tracer(ConnectivityTracer{S}, index)\ntracer(ConnectivityTracer{S}, indices)\ntracer(JacobianTracer{S}, index)\ntracer(JacobianTracer{S}, indices)\ntracer(HessianTracer{S}, index)\ntracer(HessianTracer{S}, indices)\n\nConvenience constructor for ConnectivityTracer, JacobianTracer and HessianTracer from input indices. The provided set type S has to be an AbstractSet{<:Integer}, e.g. BitSet or Set{UInt64}.\n\nExample\n\njulia> tracer(JacobianTracer{BitSet}, 2)\nJacobianTracer{BitSet}(2,)\n\njulia> tracer(HessianTracer{Set{UInt64}}, 2)\nHessianTracer{Set{UInt64}}(\n  2 => (),\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseConnectivityTracer.trace_input","page":"API Reference","title":"SparseConnectivityTracer.trace_input","text":"trace_input(T, x)\ntrace_input(T, x)\n\nEnumerates input indices and constructs the specified type T of tracer. Supports ConnectivityTracer, JacobianTracer and HessianTracer.\n\nExample\n\njulia> x = rand(3);\n\njulia> trace_input(ConnectivityTracer{BitSet}, x)\n3-element Vector{ConnectivityTracer{BitSet}}:\n ConnectivityTracer{BitSet}(1,)\n ConnectivityTracer{BitSet}(2,)\n ConnectivityTracer{BitSet}(3,)\n\njulia> trace_input(JacobianTracer{BitSet}, x)\n3-element Vector{JacobianTracer{BitSet}}:\n JacobianTracer{BitSet}(1,)\n JacobianTracer{BitSet}(2,)\n JacobianTracer{BitSet}(3,)\n\njulia> trace_input(HessianTracer{BitSet}, x)\n3-element Vector{HessianTracer{BitSet}}:\n HessianTracer{BitSet}(\n  1 => (),\n)\n HessianTracer{BitSet}(\n  2 => (),\n)\n HessianTracer{BitSet}(\n  3 => (),\n)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Utility to extract input indices from tracers:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"inputs","category":"page"},{"location":"api/#SparseConnectivityTracer.inputs","page":"API Reference","title":"SparseConnectivityTracer.inputs","text":"inputs(tracer)\n\nReturn input indices of a ConnectivityTracer or JacobianTracer\n\nExample\n\njulia> a = tracer(ConnectivityTracer{BitSet}, 2)\nConnectivityTracer{BitSet}(2,)\n\njulia> b = tracer(ConnectivityTracer{BitSet}, 4)\nConnectivityTracer{BitSet}(4,)\n\njulia> c = a + b\nConnectivityTracer{BitSet}(2, 4)\n\njulia> inputs(c)\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n\n\n","category":"function"},{"location":"#SparseConnectivityTracer.jl","page":"Home","title":"SparseConnectivityTracer.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Aqua)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast Jacobian and Hessian sparsity detection via operator-overloading.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[!WARNING] This package is in early development. Expect frequent breaking changes and refer to the stable documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this package, open the Julia REPL and run ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add SparseConnectivityTracer","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Jacobian","page":"Home","title":"Jacobian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For functions y = f(x) and f!(y, x), the sparsity pattern of the Jacobian of f can be obtained by computing a single forward-pass through f:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SparseConnectivityTracer\n\njulia> x = rand(3);\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> pattern(f, JacobianTracer{BitSet}, x)\n3×3 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 4 stored entries:\n 1  ⋅  ⋅\n 1  1  ⋅\n ⋅  ⋅  1","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a larger example, let's compute the sparsity pattern from a convolutional layer from Flux.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SparseConnectivityTracer, Flux\n\njulia> x = rand(28, 28, 3, 1);\n\njulia> layer = Conv((3, 3), 3 => 8);\n\njulia> pattern(layer, JacobianTracer{BitSet}, x)\n5408×2352 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 146016 stored entries:\n⎡⠙⢦⡀⠀⠀⠘⢷⣄⠀⠀⠈⠻⣦⡀⠀⠀⠀⎤\n⎢⠀⠀⠙⢷⣄⠀⠀⠙⠷⣄⠀⠀⠈⠻⣦⡀⠀⎥\n⎢⢶⣄⠀⠀⠙⠳⣦⡀⠀⠈⠳⢦⡀⠀⠈⠛⠂⎥\n⎢⠀⠙⢷⣄⠀⠀⠈⠻⣦⡀⠀⠀⠙⢦⣄⠀⠀⎥\n⎢⣀⡀⠀⠉⠳⣄⡀⠀⠈⠻⣦⣀⠀⠀⠙⢷⡄⎥\n⎢⠈⠻⣦⡀⠀⠈⠛⢦⡀⠀⠀⠙⢷⣄⠀⠀⠀⎥\n⎢⠀⠀⠈⠻⣦⡀⠀⠀⠙⢷⣄⠀⠀⠙⠷⣄⠀⎥\n⎢⠻⣦⡀⠀⠈⠙⢷⣄⠀⠀⠉⠻⣦⡀⠀⠈⠁⎥\n⎢⠀⠀⠙⢦⣀⠀⠀⠙⢷⣄⠀⠀⠈⠻⣦⡀⠀⎥\n⎢⢤⣄⠀⠀⠙⠳⣄⡀⠀⠉⠳⣤⡀⠀⠈⠛⠂⎥\n⎢⠀⠙⢷⣄⠀⠀⠈⠻⣦⡀⠀⠈⠙⢦⡀⠀⠀⎥\n⎢⣀⠀⠀⠙⢷⣄⡀⠀⠈⠻⣦⣀⠀⠀⠙⢷⡄⎥\n⎢⠈⠳⣦⡀⠀⠈⠻⣦⡀⠀⠀⠙⢷⣄⠀⠀⠀⎥\n⎢⠀⠀⠈⠻⣦⡀⠀⠀⠙⢦⣄⠀⠀⠙⢷⣄⠀⎥\n⎢⠻⣦⡀⠀⠈⠙⢷⣄⠀⠀⠉⠳⣄⡀⠀⠉⠁⎥\n⎢⠀⠈⠛⢦⡀⠀⠀⠙⢷⣄⠀⠀⠈⠻⣦⡀⠀⎥\n⎢⢤⣄⠀⠀⠙⠶⣄⠀⠀⠙⠷⣤⡀⠀⠈⠻⠆⎥\n⎢⠀⠙⢷⣄⠀⠀⠈⠳⣦⡀⠀⠈⠻⣦⡀⠀⠀⎥\n⎣⠀⠀⠀⠙⢷⣄⠀⠀⠈⠻⣦⠀⠀⠀⠙⢦⡀⎦","category":"page"},{"location":"#Hessian","page":"Home","title":"Hessian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For scalar functions y = f(x), the sparsity pattern of the Hessian of f can be obtained by computing a single forward-pass through f:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x = rand(5);\n\njulia> f(x) = x[1] + x[2]*x[3] + 1/x[4] + 1*x[5];\n\njulia> pattern(f, HessianTracer{BitSet}, x)\n5×5 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 3 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅\n\njulia> g(x) = f(x) + x[2]^x[5];\n\njulia> pattern(g, HessianTracer{BitSet}, x)\n5×5 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 7 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  1  ⋅  1\n ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅\n ⋅  1  ⋅  ⋅  1","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailled examples, take a look at the documentation.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SparseDiffTools.jl: automatic sparsity detection via Symbolics.jl and Cassette.jl\nSparsityTracing.jl: automatic Jacobian sparsity detection using an algorithm based on SparsLinC by Bischof et al. (1996)","category":"page"}]
}
