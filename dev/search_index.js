var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SparseConnectivityTracer","category":"page"},{"location":"#SparseConnectivityTracer","page":"Home","title":"SparseConnectivityTracer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SparseConnectivityTracer.","category":"page"},{"location":"#API-reference","page":"Home","title":"API reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Interface","page":"Home","title":"Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"connectivity","category":"page"},{"location":"#SparseConnectivityTracer.connectivity","page":"Home","title":"SparseConnectivityTracer.connectivity","text":"connectivity(f, x)\n\nEnumerates inputs x and primal outputs y=f(x) and returns sparse connectivity matrix C of size (m, n) where C[i, j] is true if the compute graph connects the i-th entry in y to the j-th entry in x.\n\nExample\n\njulia> x = rand(3);\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> connectivity(f, x)\n3×3 SparseArrays.SparseMatrixCSC{Bool, UInt64} with 4 stored entries:\n 1  ⋅  ⋅\n 1  1  ⋅\n ⋅  ⋅  1\n\n\n\n\n\nconnectivity(f!, y, x)\n\nEnumerates inputs x and primal outputs y after f!(y, x) and returns sparse connectivity matrix C of size (m, n) where C[i, j] is true if the compute graph connects the i-th entry in y to the j-th entry in x.\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SparseConnectivityTracer works by pushing a Number type called Tracer through generic functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tracer\ntracer\ntrace_input","category":"page"},{"location":"#SparseConnectivityTracer.Tracer","page":"Home","title":"SparseConnectivityTracer.Tracer","text":"Tracer(indexset) <: Number\n\nNumber type keeping track of input indices of previous computations.\n\nSee also the convenience constructor tracer. For a higher-level interface, refer to connectivity.\n\nExamples\n\nBy enumerating inputs with tracers, we can keep track of input connectivities:\n\njulia> xt = [tracer(1), tracer(2), tracer(3)]\n3-element Vector{Tracer}:\n Tracer(1,)\n Tracer(2,)\n Tracer(3,)\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> yt = f(xt)\n3-element Vector{Tracer}:\n   Tracer(1,)\n Tracer(1, 2)\n   Tracer(3,)\n\nThis works by overloading operators to either keep input connectivities constant,  compute unions or set connectivities to zero:\n\njulia> x = tracer(1, 2, 3)\nTracer(1, 2, 3)\n\njulia> sin(x)  # Most operators don't modify input connectivities.\nTracer(1, 2, 3)\n\njulia> 2 * x^3\nTracer(1, 2, 3)\n\njulia> zero(x) # Tracer is strictly operator overloading... \nTracer()\n\njulia> 0 * x   # ...and doesn't look at input values.\nTracer(1, 2, 3)\n\njulia> y = tracer(3, 5)\nTracer(3, 5)\n\njulia> x + y   # Operations on two Tracers construct union sets\nTracer(1, 2, 3, 5)\n\njulia> x ^ y\nTracer(1, 2, 3, 5)\n\nTracer also supports random number generation and pre-allocations:\n\njulia> M = rand(Tracer, 3, 2)\n3×2 Matrix{Tracer}:\n Tracer()  Tracer()\n Tracer()  Tracer()\n Tracer()  Tracer()\n\njulia> similar(M)\n3×2 Matrix{Tracer}:\n Tracer()  Tracer()\n Tracer()  Tracer()\n Tracer()  Tracer()\n\njulia> M * [x, y]\n3-element Vector{Tracer}:\n Tracer(1, 2, 3, 5)\n Tracer(1, 2, 3, 5)\n Tracer(1, 2, 3, 5)\n\n\n\n\n\n","category":"type"},{"location":"#SparseConnectivityTracer.tracer","page":"Home","title":"SparseConnectivityTracer.tracer","text":"tracer(index)\ntracer(indices)\n\nConvenience constructor for Tracer from input indices.\n\n\n\n\n\n","category":"function"},{"location":"#SparseConnectivityTracer.trace_input","page":"Home","title":"SparseConnectivityTracer.trace_input","text":"trace_input(x)\n\nEnumerates input indices and constructs Tracers.\n\nExample\n\njulia> x = rand(3);\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> xt = trace_input(x)\n3-element Vector{Tracer}:\n Tracer(1,)\n Tracer(2,)\n Tracer(3,)\n\njulia> yt = f(xt)\n3-element Vector{Tracer}:\n   Tracer(1,)\n Tracer(1, 2)\n   Tracer(3,)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"The following utilities can be used to extract input indices from Tracers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"inputs\nsortedinputs","category":"page"},{"location":"#SparseConnectivityTracer.inputs","page":"Home","title":"SparseConnectivityTracer.inputs","text":"inputs(tracer)\n\nReturn raw UInt64 input indices of a Tracer. See also sortedinputs.\n\nExample\n\njulia> t = tracer(1, 2, 4)\nTracer(1, 2, 4)\n\njulia> inputs(t)\n3-element Vector{UInt64}:\n 0x0000000000000004\n 0x0000000000000002\n 0x0000000000000001\n\n\n\n\n\n","category":"function"},{"location":"#SparseConnectivityTracer.sortedinputs","page":"Home","title":"SparseConnectivityTracer.sortedinputs","text":"sortedinputs(tracer)\nsortedinputs([T=Int], tracer)\n\nReturn sorted input indices of a Tracer. See also inputs.\n\nExample\n\njulia> t = tracer(1, 2, 4)\nTracer(1, 2, 4)\n\njulia> sortedinputs(t)\n3-element Vector{Int64}:\n 1\n 2\n 4\n\njulia> sortedinputs(UInt8, t)\n3-element Vector{UInt8}:\n 0x01\n 0x02\n 0x04\n\n\n\n\n\n","category":"function"}]
}
